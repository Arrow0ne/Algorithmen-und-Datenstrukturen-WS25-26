#lang racket/base

(define (sinus-approx x)
  (if (<= (abs x) 0.1) ;es wird der betrag von  angeschaut das ja bsp eine negative zahl kleiner wäre und das ist falsch das bedeutet man muss den betrag nehmen
      x
      (let ((sApx (sinus-approx (/ x 3.0)))) ;es wird defniert zur vereinfachung
        (- (* 3 sApx) (* 4 (expt sApx 3)))))) ;die rechnung von sinus


(sinus-approx 0.01)
(sinus-approx 100)

;------------------------------------------

(define (count-perm x)
  (count-iter 1 1 x)) ;count iter wird festgelegt

(define (count-iter produkt zaehler n) ; man zerlegt es in zaehler produkt und n
  (if (> zaehler n) ; wenn der zaehler größer ist als die zahl die gegeben wird wird am ende das produkt bzw die fakultaet ausgegeben
      produkt ; die vollendete fakultaet
      (count-iter (* zaehler produkt) (+ zaehler 1) n))) ;count iter wird hier nochmal genauer defniert mit rechnung der fakultaet und zwischen gespeichert

(count-perm 2)
(count-perm 3)
(count-perm 5)

;------------------------------------------

(define (isbn-test isbn)
  (define (iter zahl counter summe)           ; iterativer prozess zahl (die gekürzte isbn) counter (der zähler) summe (die jerweilige ziffer zum counter)
    (if (= counter 0)                         ; prüft ob der counter über 9 ist um zu sagen wann ende ist
        (if (= (remainder summe 11) 10)       ; prüft ob die kontrollzahl gleich 10 ist
            "X"
            (remainder summe 11))             ; rechnet die kontrollzahl aus
        (iter (quotient zahl 10) (- counter 1) (+ summe (* counter (remainder zahl 10)))))) ; zahl wird um 1 verkürzt, counter +1, die rechnung wird in der summe gespeichert
    (iter isbn 9 0))                         ; die werte werden festgelegt

(isbn-test 344615497)
(isbn-test 026201153) 
(isbn-test 392511825) ;Counter muss aber rückwärtslaufen da man bei quotient und remainder halt die letzten ziffern nimmt und nicht die vorne somit gewichtet man die ziffern falsch

;------------------------------------------

(define pi 3.1415926535897932384626433832795) ; Pi blabla nicht in klammern wenn was in klammern bedeutet es es ist eine funktion und nicht eine variable mit wert

(define (zylinder-kegel radius-zylinder hoehe-zylinder radius-kegel hoehe-kegel)
  (let* ((zylinder-volumen (* pi (expt radius-zylinder 2.0) hoehe-zylinder))
        (kegel-volumen (* (/ 1.0 3.0) pi (expt radius-kegel 2.0) hoehe-kegel))
        (zyl-kegel (/ zylinder-volumen kegel-volumen))) ;quotient kann man hier nicht nutzen, da quotient nur für integer ist also ganze zahlen hier sind kommazahlen
    zyl-kegel))

(zylinder-kegel 3 5 3 5)


  

